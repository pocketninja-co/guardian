package pdf

import (
	"fmt"
	"os"
	"strings"
	"time"

	"hipaa-app/internal/storage"

	"github.com/johnfercher/maroto/pkg/color"
	"github.com/johnfercher/maroto/pkg/consts"
	"github.com/johnfercher/maroto/pkg/pdf"
	"github.com/johnfercher/maroto/pkg/props"
)

type PDFService struct{}

func NewPDFService() *PDFService {
	return &PDFService{}
}

func (s *PDFService) GenerateCertificate(filename string, riskScore int) (string, error) {
	m := pdf.NewMaroto(consts.Portrait, consts.A4)

	// Settings
	m.SetPageMargins(20, 10, 20)

	// Header
	m.RegisterHeader(func() {
		m.Row(20, func() {
			m.Col(12, func() {
				m.Text("HIPAA Compliance Certificate", props.Text{
					Size:  24,
					Style: consts.Bold,
					Align: consts.Center,
				})
			})
		})
	})

	// Body
	m.Row(40, func() {
		m.Col(12, func() {
			m.Text(fmt.Sprintf("Certificate of Analysis for: %s", filename), props.Text{
				Size:  12,
				Style: consts.Normal,
				Align: consts.Center,
				Top:   10,
			})
		})
	})

	m.Row(20, func() {
		m.Col(12, func() {
			m.Text(fmt.Sprintf("Scan Date: %s", time.Now().Format("2006-01-02 15:04:05")), props.Text{
				Size:  10,
				Style: consts.Italic,
				Align: consts.Center,
			})
		})
	})

	// Result
	// Result
	status := "CLEAN"
	c := color.Color{Red: 0, Green: 255, Blue: 0}
	if riskScore > 0 {
		status = fmt.Sprintf("AT RISK (Score: %d)", riskScore)
		c = color.Color{Red: 255, Green: 0, Blue: 0}
	}

	m.Row(30, func() {
		m.Col(12, func() {
			m.Text("Status: "+status, props.Text{
				Size:  18,
				Style: consts.Bold,
				Align: consts.Center,
				Color: c,
			})
		})
	})

	// Footer
	m.RegisterFooter(func() {
		m.Row(10, func() {
			m.Col(12, func() {
				m.Text("Generated by HIPAA Data Guardian", props.Text{
					Size:  8,
					Align: consts.Right,
				})
			})
		})
	})

	// Output Path
	outputPath := fmt.Sprintf("%s_certificate.pdf", filename)
	
	// Create the PDF file
	err := m.OutputFileAndClose(outputPath)
	if err != nil {
		return "", err
	}
	
	// Get absolute path (simplified)
	absPath, err := os.Getwd()
	if err != nil {
		return outputPath, nil
	}

	return fmt.Sprintf("%s/%s", absPath, outputPath), nil
}

// RiskAuditData interface matching AuditReport struct fields needed for the report
type RiskAuditData interface {
	GetTotalFiles() int
	GetCriticalCount() int
	GetPotentialLiability() int
	GetTopOffenders() []OffenderData
}

type OffenderData interface {
	GetFilePath() string
	GetRiskLabel() string
	GetEstimatedFine() int
}

// GenerateAuditReport creates a detailed PDF report
// We accept interface{} and manually cast or use struct from risk package to avoid circular deps
// ideally we should move shared types to a separate package. For now, we redefine a local struct for input
// or accept specific fields. To keep it simple, we'll assume the caller passes struct compatible data.
// BUT, since we can't easily import `risk` here due to potential circular dependency (if risk imports pdf),
// let's just duplicate the struct definition locally or accept distinct params.
// ACTUALLY: app.go imports both, so they are siblings. risk imports nothing from pdf.
// So we can import "hipaa-app/internal/risk" here if we wanted, but// GenerateAuditReport creates a detailed PDF report
func (s *PDFService) GenerateAuditReport(totalFiles, criticalCount, liability int, topOffenders [][]string, outputPath string) (string, error) {
	m := pdf.NewMaroto(consts.Portrait, consts.A4)
	m.SetPageMargins(20, 10, 20)

	// Header
	m.RegisterHeader(func() {
		m.Row(20, func() {
			m.Col(12, func() {
				m.Text("HIPAA Risk Audit Report", props.Text{
					Size:  22,
					Style: consts.Bold,
					Align: consts.Center,
				})
			})
		})
	})

	// Summary
	m.Row(10, func() {
		m.Col(12, func() {
			m.Text(fmt.Sprintf("Generated: %s", time.Now().Format("2006-01-02 15:04:05")), props.Text{
				Size: 10, Style: consts.Italic, Align: consts.Center,
			})
		})
	})
	
	m.Row(40, func() {
		m.Col(4, func() {
			m.Text(fmt.Sprintf("Files Scanned: %d", totalFiles), props.Text{Size: 12, Top: 5})
		})
		m.Col(4, func() {
			m.Text(fmt.Sprintf("Critical Risks: %d", criticalCount), props.Text{Size: 12, Top: 5, Color: color.Color{Red: 255, Green: 0, Blue: 0}})
		})
		m.Col(4, func() {
			m.Text(fmt.Sprintf("Liability: $%d", liability), props.Text{Size: 14, Top: 5, Style: consts.Bold})
		})
	})

	// Top Offenders Table
	m.Row(10, func() {
		m.Col(12, func() {
			m.Text("Top Critical Violations", props.Text{Size: 14, Style: consts.Bold, Top: 5})
		})
	})

	header := []string{"Risk", "File Path", "Est. Fine"}
	m.TableList(header, topOffenders, props.TableList{
		HeaderProp: props.TableListContent{
			Size:      10,
			GridSizes: []uint{2, 8, 2},
		},
		ContentProp: props.TableListContent{
			Size:      9,
			GridSizes: []uint{2, 8, 2},
		},
	})

	// Output
	finalPath := outputPath
	if finalPath == "" {
		finalPath = fmt.Sprintf("audit_report_%d.pdf", time.Now().Unix())
		absPath, _ := os.Getwd()
		finalPath = fmt.Sprintf("%s/%s", absPath, finalPath)
	}
	
	err := m.OutputFileAndClose(finalPath)
	if err != nil {
		return "", err
	}

	return finalPath, nil
}

// GenerateComplianceCertificate creates an official Certificate of Compliance for clean scans
func (s *PDFService) GenerateComplianceCertificate(totalFiles int, deviceName string, auditHistory []storage.AuditEntry, outputPath string) (string, error) {
	m := pdf.NewMaroto(consts.Portrait, consts.A4)
	m.SetPageMargins(20, 10, 20)
	
	// Header (Seal)
	m.RegisterHeader(func() {
		m.Row(20, func() {
			m.Col(12, func() {
				m.Text("HIPAA DATA GUARDIAN", props.Text{
					Top:   5,
					Style: consts.Bold,
					Size:  20,
					Align: consts.Center,
					Color: getDarkGrayColor(),
				})
			})
		})
	})

	// Certificate Body
	m.Row(40, func() {
		m.Col(12, func() {
			m.Text("CERTIFICATE OF COMPLIANCE", props.Text{
				Top:   25,
				Style: consts.Bold,
				Size:  26,
				Align: consts.Center,
				Color: getBlueColor(),
			})
		})
	})

	m.Row(10, func() {
		m.Col(12, func() {
			m.Text("This document certifies that the device known as:", props.Text{
				Top:   0,
				Style: consts.Normal,
				Size:  12,
				Align: consts.Center,
			})
		})
	})

	m.Row(15, func() {
		m.Col(12, func() {
			m.Text(strings.ToUpper(deviceName), props.Text{
				Top:   0,
				Style: consts.BoldItalic,
				Size:  16,
				Align: consts.Center,
			})
		})
	})

	m.Row(20, func() {
		m.Col(12, func() {
			m.Text("Has successfully passed a comprehensive HIPAA Data Audit with ZERO detections of unprotected PHI (Protected Health Information).", props.Text{
				Top:   0,
				Style: consts.Normal,
				Size:  12,
				Align: consts.Center,
			})
		})
	})

	// Stats Box
	m.Row(30, func() {
		m.ColSpace(3)
		m.Col(6, func() {
			m.Text(fmt.Sprintf("Scanned Files: %d  |  Risks Found: 0  |  Status: SECURE", totalFiles), props.Text{
				Top:   10,
				Style: consts.Bold,
				Size:  10,
				Align: consts.Center,
				Color: getGreenColor(),
			})
		})
		m.ColSpace(3)
	})

	// Footer / Signatures
	m.Row(40, func() {
		m.Col(6, func() {
			m.Signature("Authorized Officer", props.Font{
				Size: 10,
				Style: consts.Bold,
			})
		})
		m.Col(6, func() {
			m.Text(fmt.Sprintf("Date: %s", time.Now().Format("2006-01-02")), props.Text{
				Top:   25,
				Style: consts.Bold,
				Size:  10,
				Align: consts.Right,
			})
		})
	})

	// Save
	finalPath := outputPath
	if finalPath == "" {
		finalPath = fmt.Sprintf("compliance_cert_%d.pdf", time.Now().Unix())
		// If using default, prepend cwd
		absPath, _ := os.Getwd()
		finalPath = fmt.Sprintf("%s/%s", absPath, finalPath)
	}
	
	err := m.OutputFileAndClose(finalPath)
	if err != nil {
		return "", err
	}
	
	return finalPath, nil
}

func getDarkGrayColor() color.Color {
	return color.Color{Red: 50, Green: 50, Blue: 50}
}

func getBlueColor() color.Color {
	return color.Color{Red: 0, Green: 102, Blue: 204}
}

func getGreenColor() color.Color {
	return color.Color{Red: 0, Green: 128, Blue: 0}
}
